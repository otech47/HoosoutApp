{
  "name": "searchjs",
  "description": "A library for filtering JavaScript objects based on a json SQL-like language, jsql",
  "version": "0.3.4",
  "url": "http://github.com/deitch/searchjs",
  "author": {
    "name": "Avi Deitcher",
    "email": "avi@deitcher.net"
  },
  "contributors": [
    {
      "name": "Ed Hotchkiss",
      "url": "https://github.com/edwardhotchkiss"
    }
  ],
  "engines": [
    "node >= 0.3"
  ],
  "main": "./lib/searchjs.js",
  "repository": {
    "type": "git",
    "url": "http://github.com/deitch/searchjs.git"
  },
  "devDependencies": {
    "mocha": "~1.13.0",
    "should": "~1.3.0"
  },
  "scripts": {
    "test": "node ./test/test.js"
  },
  "dependencies": {},
  "readme": "# jsql\n\n## Overview\njsql is a JavaScript query language, along with a simple JavaScript objects (POJSO) reference implementation. \n\nThis is not intended to search the dom, or jQuery, or some specific database, nor is it intended to enable using SQL in a browser.\njsql is intended to provide a native JSON query format for querying anything, although initially limited to JavaScript objects.\n\n## Reference Implementation\nThe reference implementation, searchjs, uses jsql to query a JS object, or an array of objects, and to return those results that match\nthe query.\n\n\n## Syntax Definition\njsql syntax is defined as follows.\n\njsql *always* is a single JavaScript object: `{}` with properties that determine the parameters for the query.\n\nThere are three kinds of properties for a query:\n\n* Primitives: Primitives match one or more fields on AND or OR, with or without a negation. \n* Modifiers: Modifiers determine how the other properties are treated: negation, field join type, ranges and text searches.\n* Composites: Composites join multiple primitives. The primitives are in an array in the field \"terms\". See example 7.\n\n### Primitives\nA primitive is an object with properties that are matched. \n\n* `{name:\"John\"}` - primitive that checks that the name field is equal to \"John\"\n\nMultiple fields in a primitive are, by default, joined by logical AND. See under Modifiers to change this.\n\n* `{name:\"John\",age:30}` - primitive that checks that the name field is equal to \"John\" AND that the age field is equal to 30\n\nThe name of a field in a primitive is *always* the name of the field to match in the record. The value can be one of:\n\n* Basic types: string, number - will match directly against the value in the record. Case is **ignored** in string matches.\n* Array: will match against any one of the values in the array. See below.\n* Object: will look for a range. See below.\n\n#### Array Primitive\nIf the value of a field in a primitive is an array, then it will accept a match of any one of the array values. \n\n````JavaScript\n{name:[\"John\",\"Jack\"]} // accepts any record where the name field matches 'John' or 'Jack'\n{_join:\"OR\",terms:[{name:\"John\"},{name:\"Jack\"}]} // equivalent to the previous\n````\n\nAdditionally, if the target record also has an array, it will accept a match if *any one* of the values in the array of the record matches *any one* of the values in the array of the search term.\n\n````JavaScript\n{name:[\"John\",\"Jack\"]}\n````\n\nwill match any of these:\n\n````JavaScript\n{name:\"John\",phone:\"+12125551212\"}\n{name:\"Jack\",location:\"Canada\"}\n{name:[\"John\",\"Jim\"],company:\"Hot Startup\"}\n````\n\n#### Range\nIf the value of a field in a primitive is an object with \"from\" or \"to\" or \"gt\" or \"lt\" fields, then it will treat it as a range.\n\n````JavaScript\n{age:{from:30}}  // accepts any age >=30\n{age:{gt:30}}  // accepts any age >=30\n{age:{to:80}}    // accepts any age <=80\n{age:{lt:80}}    // accepts any age <=80\n{age:{from:30,to:80}}  // accepts any age from 30 to 80 (inclusive)\n{_not:true,age:{from:30}} // accepts any age <30\n{age:{nothing:\"foo\"}}  // ignored\n````\n\nAccept values in `to` and `from` fields in a range are numbers and strings. The type of the target record's data **must** match the type of the value of `from` and `to`. If not, it is treated as unmatched. You **cannot** match `{age:{from:30}}` to a record `{age:\"veryold\"}`!\n\nNote that \"gt\" and \"from\", and \"lt\" and \"to\", are interchangeable. Yes, it should be that \"gte\" is equivalent to \"from\" (>=) while \"gt\" is equivalent to \">\", but we aren't there yet.\n\n\n### Modifiers\nModifiers change the search term of a primitive.\n\n#### Negation\nNegation just sets the opposite. Instead of checking if the \"name\" field equals \"John\", you can check if it does *not* equal \"John\":\n\n````JavaScript\n{name:\"John\",_not:true}   // match all records in which name !== \"John\"\n````\n\nJust add the field `_not` to the primitive and set it to `true`. If the `_not` field does not exist, or is set to `false` or `null`, it will be ignored.\n\n#### Join\nJoin determines how multiple fields are put together. Instead of checking if \"name\" equals \"John\" AND \"age\" equals 30, you can check if \"name\" equals \"John\" OR \"age\" equals 30:\n\n````JavaScript\n{name:\"John\",age:30,_join:\"OR\"}   // match all records in which name === \"John\" || age === 30\n````\n\nJust add the field `_join` to the primitive and set it to \"OR\". If the `_join` field does not exist, or is set to \"AND\", it will join the field in \"AND\".\n\n\n#### Text Searching\nIn general, if you search a field that is a string, and the search primitive is a string, then it will be an exact match, ignoring case.\n\n`{name:\"davi\"}` will match a record whose content is `{name:\"davi\"}`, as well as one whose \"name\" field matches \"Davi\" and \"DAVID\", but not one whose content is `{name:\"david\"}` or even `{name: \"davi abc\"}`.\n\nIf you want a text search that can do partial matches, text searching is here to help!\n\nThere are two variants on text search that can expand your ability to search text fields:\n\n1. substring: if you set the flag `{_text: true}` as part of your search, then it searches for your match *as part of the field*. In other words, if your search is `{name:\"davi\", _text:true}` then it will check if the field matches `/davi/i`.\n2. word: if you set the flag `{_word: true}` as part of your search, then it search for your match *as a complete word in the field*. In other words, if your search is `{name:\"davi\",_word:true}` then it will check if the field matches `/\\bdavi\\b/i`.\n\nThe `_text` option will override the `_word` option if both exist.\n\nHere are some examples of text searching:\n\n* `{name:\"davi\"}` matches all of `{name:\"davi\"}, {name:\"DAvi\"}` but none of `{name:\"david\"}, {name:\"abc davi def\"}`\n* `{name:\"davi\",_word:true}` matches all of `{name:\"davi\"}, {name:\"DAvi\"}, {name:\"abc davi def\"}` but none of `{name:\"david\"}`\n* `{name:\"davi\",_text:true}` matches all of `{name:\"davi\"}, {name:\"DAvi\"}, {name:\"abc davi def\"}, {name:\"abdavideq\"}`\n\n\n### Composites\nIf you want to combine multiple composites into a single search term, you put them in an array, name it \"terms\", and create a composite search term. You can search for (\"name\" equals \"John\" and age equals 30) OR (\"name\" equals \"Jill\" and \"location\" equals \"Canada\"):\n\n````JavaScript\n{_join:\"OR\",terms:[{name:\"John\",age:30},{name:\"Jill\",location:\"Canada\"}]}\n````\n\nComposities can be layered inside composites, since each term in `terms` can itself be a composite.\n\n## Examples\n\n1. `{name: \"John\", age: 30}` - all records that have name === \"John\" (ignore-case) && age === 30\n2. `{_join: \"AND\", name: \"John\", age: 30}` - all records that have name === \"John\" (ignore-case) && age === 30 (same as above)\n3. `{_join: \"OR\", name: \"John\", age: 30}` - all records that have name === \"John\" (ignore-case) || age === 30\n4. `{_not: true, name: \"John\"}` - all records that have name !== \"John\" (ignore-case)\n5. `{_not: true, name: \"John\", age: 30}` - all records that have name !== \"John\" (ignore-case) AND age !== 30\n6. `{_not: true, _join: \"OR\", name: \"John\", age: 30}` - all records that have name !== \"John\" (ignore-case) OR age !== 30\n7. `{_join: \"OR\", terms: [{name:\"John\", age:30},{age:35}]}` - all records that have (name === \"John\" && age === 30) || (age === 35)\n8. `{email: \"john@foo.com\"}` - all records that have the email === \"john@foo.com\", if the record has email as a string; or if email is an array, then each element is checked; or if email is an object, then the keys are checked. All of the following will match: `{email:\"john@foo.com\"}` and `{email:[\"john@foo.com\",\"js@gmail.com\"]}` and `{email:{\"john@foo.com\":true}}`\n9. `{name:[\"John\",\"Jill\"]}` - all records that have name === \"John\" || name === \"Jill\"\n10. `{email:[\"john@foo.com\",\"jf@gmail.com\"]}` - all records that have email === \"john@foo.com\" || email === \"jf@gmail.com\" OR email in the record is an array, and at least one value in that array is \"john@foo.com\" or \"jf@gmail.com\"\n11. `{_not: true, name:[\"John\",\"Jill\"]}` - all records that have name !== \"John\" && name !== \"Jill\"\n12. `{_not:true, email:[\"john@foo.com\",\"jf@gmail.com\"]}` - all records that have (email !== \"john@foo.com\" && email !== \"jf@gmail.com\") OR email in the record is an array, and not one single value in that array is \"john@foo.com\" or \"jf@gmail.com\"\n13. `{age: 30}` - all records that have age === 30\n14. `{age: 30, _not: true}` - all records that have age !== 30\n14. `{age: {from:30, to:35}}` - all records that have age >= 30 && age <=35\n14. `{age: {gt:30, lt:35}}` - all records that have age >= 30 && age <=35\n14. `{_not: true, age: {from:30, to:35}}` - all records that have age !(>= 30 && age <=35) i.e. age < 30 || age > 35\n15. `{name: \"John\", age: {from:30, to:35}}` - all records that have name === \"John\" && age >= 30 && age <=35\n15. `{_not: true, name: \"John\", age: {from:30, to:35}}` - all records that have name !== \"John\" && age !(>= 30 && age <=35)\n15. `{terms:[{name: \"John\"}, {_not: true, age: {from:30, to:35}}]}` - all records that have name === \"John\" && age !(>= 30 && age <=35)\n\n\n# searchjs\n\n## Overview\nsearchjs is the reference implementation of jsql. It uses jsql to check if an object matches a query, or to go through a \nlist of objects and return those that match. For now, it uses objects in memory only; in the future, it could be extended\nto other data stores.\n\n## Installation & Usage\n\n### Node\nIn node, install using:\n\n\tnpm install searchjs\n\nBrowser-version is being worked on. There is nothing node-specific about search js.\n\nNext, require it using:\n\tvar s = require('searchjs');\n\nMake a query. There are two types of searches: matchObject and matchArray.\n\n* `matchObject(object,jsqlObject)`: matchObject returns boolean true or false, depending on whether or not the given object matches the given search. \n* `matchArray(array,jsqlObject)`: matchArray returns an array of items, subset of the passed array, that match match the given search.\n\nAll objects are stateless. The following examples show how to use matchObject and matchArray. For more details, look at the test.js\nfile included with searchjs.\n\n````JavaScript\nvar list = [{name:\"John\",age:25},{name:\"Jill\",age:30}];\nmatches = s.matchObject(list[0],{name:\"Johnny\"}); // returns false\nmatches = s.matchArray(list,{name:\"John\"}); // returns [{name:\"John\",age:25}]\n````\n\n\n### Browser\nIn the browser, you simply need to include the file lib/search.js. Download it from github (where you are probably reading this)\nand include it in your path. Lots of libraries do require() and inclusion, but the raw, basic way to do it is:\n\n\t<script src=\"lib/searchjs.js\"></script>\n\nThis will make a global variable SEARCHJS in your window. You can then use it as above:\n\n````JavaScript\nvar list = [{name:\"John\",age:25},{name:\"Jill\",age:30}];\nmatches = SEARCHJS.matchObject(list[0],{name:\"Johnny\"}); // returns false\nmatches = SEARCHJS.matchArray(list,{name:\"John\"}); // returns [{name:\"John\",age:25}]\n````\n\n## Changelist\nVersion 0.3.0 adds support for query ranges. You can query `{age: {from:25,to:30}}`\n\nAs of version 0.1.1, several enhancements have been added:\n\n1. Record Array Field: If the field in the object is an array, then the match is done to each item in the array, and returns true if one or more matches. See example 8.\n2. Matcher Array Value: If the primitive value is an array, then the value in the record field is matched to each element in the array. See example 9.\n3. Combine Record Array with Matcher Array: If both the record field value is an array and the matcher value is an array, then it will return true if any one value in the record array matches any one value in the matcher field. See example 10.\n4. Negater: The \"_not\" negater can be used with Record Array and Matcher Array. See example 11.\n\nAs of version 0.1.3, several additional enhancements:\n\n5. Record Object Field: If the field in the object is itself an object, then the match is done to each key in the array, and returns true if one or more matches. See example 8.\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/deitch/searchjs/issues"
  },
  "homepage": "https://github.com/deitch/searchjs",
  "_id": "searchjs@0.3.4",
  "_shasum": "4473afcf48733964de30f1a036596557a364fc38",
  "_from": "searchjs@~0.3.1",
  "_resolved": "https://registry.npmjs.org/searchjs/-/searchjs-0.3.4.tgz"
}
